---
title: 关于时间复杂度的理解
categories:
  - 数据结构与算法
tags:
  - 算法
  - 概率论
---

# 关于时间复杂度的理解

以前看到了时间复杂度，有什么 O(1),O(log(n)),O(n),O(nlog(n))，O(n2),O(2n),O(n!)等等。<br/> O(1)就是时间复杂度与数据规模无关，数据再多，时间也是一定的。比较典型的是哈希表，以空间换时间。<br/> O(log(n))这个我之前一直不知道复杂度怎么和对数联系起来的。后来二分法，以及汉明距离计算，让我知道，原来是这样。二分法，顾名思义，排好序的一堆数据，每次从中间取数据与目标数据比较，分而治之，小了就从更小范围找，大了就从更大范围找，那么最坏的情况，就是遍历到最后，已经不可分割了，这个过程相当于数组大小一直除2，这个其实就相当于一直不带符号，不循环的右移，所以查找次数就是可右移的次数，也就是数据个数的二进制的位数，也就是以2为底的log(n)。汉明距离转化为异或操作之后计算1的个数，也是和数据的位数有关，以2为底的log(n)。<br/> O(n)与数据规模呈正相关。比如死循环查找数据，最坏的情况是查到最后一个才查到，那就查了n次。<br/> O(nlog(n))堆排序里，每次堆化取最值，复杂度都为O(logn)，一共需要n次操作，可以证得，堆排复杂度为O(nlog(n))。<br/> O(n^2)这里是n的平方，比如选择排序和冒泡排序，最坏的情况需要n-1+n-2+…1=n2(n的平方次)。又比如死循环计算两个给定数组的各其中一个元素加起来的最大和值，两层死循环，每个数组大小为n，n*n，n的平方。<br/> O(2^n)这里可以拿斐波那契数列的计算举例子，斐波那契数列f(n)=f(n-1)+f(n-2)，递归运算时，每次需要调用的函数都会呈指数级增长。<br/> O(n!)这个复杂度已经是很恐怖的了，看下面的图就知道了。比如写出1~n的所有全排列。

另外：

> 
O(f(n)) 代表上界，意为该算法的运行时间随数据量的增长所呈现出来的**时间—数据量关系**不会比 f(n)更差。例如给一个数组冒泡排序，它的时间复杂度是 O(n^2)，就表示给定数组长度 n，冒泡排序的运行时间不会是个比二次函数更糟糕的函数（如三次函数、指数函数等等）。但 O(f(n))并不代表该算法的时间—数据量关系恰好符合 所表达出来的数量级；它只是个上界。<br/> 对应地，Ω(g(n))代表下界，表示该算法一定不会比g(n)更快。例如刚才的冒泡排序，我们完全可以说它的时间复杂度符合Ω(logn)或者Ω(n) 等等，因为冒泡排序不可能比它们还要快。<br/> 最后， Θ(h(n))代表确界，表示该算法不快不慢，恰好跟 h(n) 是一个数量级。继续举例冒泡排序，我们可以说它具有确界 Θ(n^2)，因为冒泡排序的运行时间恰好可以用二次函数来表示。<br/> 在工业界中，算法往往是复杂的，很多时候我们很难算出它的确界，只能分析出“它一定比 XX快”（上界）或者“它一定比 XX 慢”（下界），显然这两者中上界比下界更有意义，有了上界我们就能估计出一个算法的最坏情况。


<img alt="complexity" src="https://img-blog.csdnimg.cn/8e03faa70c1146b48b379e04b8cdea00.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6aaZ6JWJ5Ymy6I2J5py6,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 参考：<br/> [1.如何理解算法时间复杂度的表示法，例如 O(n²)、O(n)、O(1)、O(nlogn) 等？](https://www.zhihu.com/question/21387264/answer/422740592)<br/> [2.算法时间复杂度为O（n!）的是什么算法？](https://www.zhihu.com/question/51497321)
